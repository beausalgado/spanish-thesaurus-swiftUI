# Ideating 
First, I brainstormed ideas of what I wanted the app to look like and have. Then I created the design.  I downloaded a number of dictionary and thesaurus apps to research, savings screenshots of features and designs that I liked in Notion. I used Figma to create six iterations of wireframes. This includes color schemes and various logos. For instance, the search bar design and functionality is based largely on Instagram’s search bar.  I create a hifi version with the help of a professional designer.

# Creating a database and structuring it
I researched various thesauruses in Spanish. I tried a few dictionary APIs on the internet such as the Oxford API or La Real Academia Española, but they didn’t have enough data or didn’t work like I needed them to. At one point, I dug into the website architecture of WordReference.com and discovered the thesaurus they use in the API call. I found a PDF version of it and found that the simple structure of the document would be helpful to scrape the data from it. I tried to copy and paste the data using multiple epub readers, including Kindle, but the data always got scrambled. I came across PDF Plumber on Stack Overflow and couldn’t get it to work on my Mac. I managed to get it up and running on my Windows computer with a little bit of Python. I’d never used Python before. I came across a number of issues still, though. I had to crop the PDF into four separate columns with the right widths and then concatenate them in order to preserve the correct order of the entries. After successfully extracting the data in the right order, I designed a JSON data structure that allowed for an object, a word, to have multiple meanings associated with it, each meaning labeled meaning1, meaning2, and so on, each meaning containing synonyms, antonyms, americanisms, and sayings. I created certain logics based on the format of the PDF, such as every word in bold is a new entry, words with the same interlinear spacing between them are synonyms assigned to one meaning, words in italics are antonyms, and large spaces that precede words that aren’t in bold indicate a new meaning for the previous entry. PDF Plumber has several tools such as X Y coordinates that measure the distance one character from the next or from a side of the page and this allowed me to make minute distinctions in my data structuring logic. When I finally got the visual debugger in PDF Plumber to work, I was able to correct certain bugs like incorrect widths of the extraction columns.

The numbered meanings turned out not be problematic for foreach loops when structuring the data in SwiftUI. So I had to restructure the JSON data such that the respective meanings were all objects within a large meaning array associated to an entry. In addition to this, I had to process the database to fix some of the bugs from PDF Plumber, such as adding “amer.”, an abbreviation for an americanism, to the synonym’s name. PDF Plumber had read them as separate things because the space between the synonym and the “amer.” wasn’t read as a character space. 

# Putting the data in the cloud
I wanted to learn how to use MongoDB. So I decided to deploy the database to MongoDB’s Atlas. I struggled with wording the mongoimport correctly, since I was uploading a JSON Array and the documentation didn’t include this keyword in the examples. Once I got the command line correct, I was able to magically upload all of the database to a collection labeled “Entries” in MongoDB Atlas.

# API
I made a routing structure with Node.js and Express to work with Mongoose so that I could set up a localhost with all the data. Later I fine tuned the routes so that, as the users types, searches match with the beginning of the entries in Atlas for the autocomplete feature to work. I also made a route that call a random entry for the synonym of the day on the home page. 

# Frontend Database
Before I could work with SwiftUI, I watched multiple playlists of a Youtube Channel called Swiftful Thinking. The developer has a bootcamp, a continued learning playlist, as well as playlists of various apps that he builds from scratch. I also watched a course on Swift from Frontend Masters. I created structs to receive and prepare the JSON data for the front end as well as a data service object with Combine to make calls to the API. I saved all of the data in publishers that could be accessed through the app. I also made the search word a publisher so that new data would be called each time the user input a single character. This allowed for the autocomplete functionality to work in real time. 

Later on I incorporated CoreData so that I could save some of the entries on the device. This was necessary for the recently searched list to work as well as the favorites list. Both the favorites entity and history entity have all the CRUD functions. A made a few additions functions such as one to determine if the entry is the last in an array so that the divider line doesn’t appear under the last item of the list in the UI. Another function checks to see if the entry already exists in the entity container to avoid savings duplicates. 

# UI
I created a splash page with animation upon opening the app. I used a tab structure with three tabs and a hamburger button in a header as the basic architecture. I implemented StateObjects at the index level which made the data available to all the children via the environment object property wrapper. I created a Heart Icon out of two overlayed hearts, one filled, one empty, with a bounce animation so as to produce the bouncy like button effect that a lot of apps have. Finally, I made a custom search bar so that I could control certain functionalities, like under what conditions the cancel button slides in from the right and so that data calls are made when the user inputs a character but not when the bar is focused. I used a lot of State property wrappers as well as the FocusState property wrapper to achieve this. I also wanted to be able to define when the autocomplete results showed, when the recently search list appears, and when the entry itself appears by itself. In the UI, I used the custom font Nunito and incorporated animations wherever I could. 
